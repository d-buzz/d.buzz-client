/* eslint-disable no-restricted-globals */

// Importing necessary Workbox modules for precaching, routing, and strategies
import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate } from 'workbox-strategies'

// Immediately take control of the page
clientsClaim()

// Precache all assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// The self.__WB_MANIFEST is replaced by Workbox during the build process.
precacheAndRoute(self.__WB_MANIFEST)

// Force the waiting service worker to become the active service worker
self.addEventListener('install', (event) => {
  self.skipWaiting()
})

// Clean up old caches and ensure cache is cleared the first time a page is loaded
self.addEventListener('activate', (event) => {
  event.waitUntil(clients.claim())
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          // Assuming self.__WB_MANIFEST is an array of all the current assets.
          // Convert self.__WB_MANIFEST to an array of cache names for comparison.
          const manifestCacheNames = self.__WB_MANIFEST.map((entry) => {
            // If the manifest entries are just strings, use as is, otherwise adapt as needed
            return typeof entry === 'string' ? entry : entry.url
          })

          // Delete caches not present in the current manifest or other necessary caches to keep
          if (!manifestCacheNames.includes(cacheName)) {
            return caches.delete(cacheName)
          }
        })
      )
    })
  )
})

// App Shell-style routing for navigation requests
registerRoute(
  ({ request, url }) => {
    if (request.mode !== 'navigate') {
      return false
    }
    return !(url.pathname.startsWith('/_') || url.pathname.match(fileExtensionRegexp))

  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html'),
)

// Runtime caching for .png files in the public directory
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  }),
)

// Listen for skipWaiting messages
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

// Add any other custom service worker logic below
